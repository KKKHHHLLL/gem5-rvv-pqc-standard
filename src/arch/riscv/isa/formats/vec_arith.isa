// -*- mode:c++ -*-

// Copyright (c) 2022 PLCT Lab
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met: redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer;
// redistributions in binary form must reproduce the above copyright
// notice, this list of conditions and the following disclaimer in the
// documentation and/or other materials provided with the distribution;
// neither the name of the copyright holders nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


let {{
    def setDestWrapper(destRegId):
        return "setDestRegIdx(_numDestRegs++, " + destRegId + ");\n" + \
            "_numVecDestRegs++;\n"
    def setSrcWrapper(srcRegId):
        return "setSrcRegIdx(_numSrcRegs++, " + srcRegId + ");\n"
    def setSrcVm():
        return "if (!this->vm)\n" + \
            "    setSrcRegIdx(_numSrcRegs++, RegId(VecRegClass, 0));"
    def vmDeclAndReadData():
        return '''
            [[maybe_unused]] RiscvISA::vreg_t tmp_v0;
            [[maybe_unused]] uint8_t* v0;
            if(!this->vm) {
                tmp_v0 = xc->readVecRegOperand(this, _numSrcRegs-1);
                v0 = tmp_v0.as<uint8_t>();
            }
        '''
    def loopWrapper(code):
        return "for (uint32_t i = 0; i < this->micro_vl; i++) {\n" + \
            code + "}\n"
    def maskCondWrapper(code):
        return "if (this->vm || elem_mask(v0, ei)) {\n" + \
            code + "}\n"
    def eiDeclarePrefix(code):
        return "uint32_t ei = i + this->microVlmax() * this->micro_idx;\n" + \
            code
}};


def format VectorIntFormat(code, category, *flags) {{
    iop = InstObjParams(name,
        Name,
        'VectorIntMacroOp',
        {'code': code},
        flags)
    split_name = name.split("_")
    insts_neednot_mask = ["vmv"]
    need_vm = split_name[0] not in insts_neednot_mask
    mask_cond = need_vm and ('m' not in split_name[1])
    need_elem_idx = mask_cond or code.find("ei") != -1

    dest_reg_id = "RegId(VecRegClass, extMachInst.vd + _micro_idx)"
    src1_reg_id = ""
    if category == "OPIVV":
        src1_reg_id = "RegId(VecRegClass, extMachInst.vs1 + _micro_idx)"
    elif category == "OPIVX":
        src1_reg_id = "RegId(IntRegClass, extMachInst.rs1)"
    elif category == "OPIVI":
        pass
    else:
        error("not supported category for VectorIntFormat: %s" % category)
    src2RegId = "RegId(VecRegClass, extMachInst.vs2 + _micro_idx)"

    set_dest_reg_idx = setDestWrapper(dest_reg_id)
    # set_src_reg_idx
    set_src_reg_idx = ""
    if category != "OPIVI":
        set_src_reg_idx += setSrcWrapper(src1_reg_id)
    set_src_reg_idx += setSrcWrapper(src2RegId)
    if need_vm:
        set_src_reg_idx += setSrcVm()
    # code
    if mask_cond:
        code = maskCondWrapper(code)
    if need_elem_idx:
        code = eiDeclarePrefix(code)
    code = loopWrapper(code)

    vm_decl_rd = ""
    if need_vm:
        vm_decl_rd = vmDeclAndReadData()

    microiop = InstObjParams(name + "_micro",
        Name + "Micro",
        'VectorIntMicroOp',
        {'code': code,
        'set_dest_reg_idx': set_dest_reg_idx,
        'set_src_reg_idx': set_src_reg_idx,
        'vm_decl_rd': vm_decl_rd},
        flags)

    header_output = \
        VectorIntMicroDeclare.subst(microiop) + \
        VectorIntMicroConstructor.subst(microiop) + \
        VectorIntMicroExecute.subst(microiop) + \
        VectorIntMacroDeclare.subst(iop) + \
        VectorIntMacroConstructor.subst(iop)
    decode_block = VectorIntDecodeBlock.subst(iop)
}};

def format VectorIntMaskFormat(code, category, *flags) {{
    iop = InstObjParams(name,
        Name,
        'VectorIntMaskMacroOp',
        {'code': code},
        flags)
    dest_reg_id = "RegId(VecRegClass, extMachInst.vd)"
    src1_reg_id = ""
    if category == "OPIVV":
        src1_reg_id = "RegId(VecRegClass, extMachInst.vs1 + _micro_idx)"
    elif category == "OPIVX":
        src1_reg_id = "RegId(IntRegClass, extMachInst.rs1)"
    elif category == "OPIVI":
        pass
    else:
        error("not supported category for VectorIntFormat: %s" % category)
    src2RegId = "RegId(VecRegClass, extMachInst.vs2 + _micro_idx)"
    set_dest_reg_idx = setDestWrapper(dest_reg_id)
    set_src_reg_idx = ""
    if category != "OPIVI":
        set_src_reg_idx += setSrcWrapper(src1_reg_id)
    set_src_reg_idx += setSrcWrapper(src2RegId)
    set_src_reg_idx += setSrcVm()
    vm_decl_rd = vmDeclAndReadData()

    code = eiDeclarePrefix(code)
    code = loopWrapper(code)

    microiop = InstObjParams(name + "_micro",
        Name + "Micro",
        'VectorIntMicroOp',
        {'code': code,
        'set_dest_reg_idx': set_dest_reg_idx,
        'set_src_reg_idx': set_src_reg_idx,
        'vm_decl_rd': vm_decl_rd},
        flags)
    header_output = \
        VectorIntMaskMicroDeclare.subst(microiop) + \
        VectorIntMaskMicroConstructor.subst(microiop) + \
        VectorIntMaskMicroExecute.subst(microiop) + \
        VectorIntMaskMacroDeclare.subst(iop) + \
        VectorIntMaskMacroConstructor.subst(iop)
    decode_block = VectorIntDecodeBlock.subst(iop)
}};

def format VectorFloatFormat(code, category, *flags) {{
    iop = InstObjParams(name,
        Name,
        'VectorFloatMacroOp',
        {'code': code},
        flags)
    split_name = name.split("_")
    insts_neednot_mask = ["vfmv"]
    need_vm = split_name[0] not in insts_neednot_mask
    mask_cond = need_vm and ('m' not in split_name[1])
    need_elem_idx = mask_cond or code.find("ei") != -1

    dest_reg_id = "RegId(VecRegClass, extMachInst.vd + _micro_idx)"
    src1_reg_id = ""
    if category == "OPFVV":
        src1_reg_id = "RegId(VecRegClass, extMachInst.vs1 + _micro_idx)"
    elif category == "OPFVF":
        src1_reg_id = "RegId(FloatRegClass, extMachInst.rs1)"
    else:
        error("not supported category for VectorIntFormat: %s" % category)
    src2RegId = "RegId(VecRegClass, extMachInst.vs2 + _micro_idx)"

    set_dest_reg_idx = setDestWrapper(dest_reg_id)
    # set_src_reg_idx
    set_src_reg_idx = ""
    set_src_reg_idx += setSrcWrapper(src1_reg_id)
    set_src_reg_idx += setSrcWrapper(src2RegId)
    if need_vm:
        set_src_reg_idx += setSrcVm()
    # code
    if mask_cond:
        code = maskCondWrapper(code)
    if need_elem_idx:
        code = eiDeclarePrefix(code)
    code = loopWrapper(code)

    vm_decl_rd = ""
    if need_vm:
        vm_decl_rd = vmDeclAndReadData()

    microiop = InstObjParams(name + "_micro",
        Name + "Micro",
        'VectorFloatMicroOp',
        {'code': code,
        'set_dest_reg_idx': set_dest_reg_idx,
        'set_src_reg_idx': set_src_reg_idx,
        'vm_decl_rd': vm_decl_rd},
        flags)

    header_output = \
        VectorFloatMicroDeclare.subst(microiop) + \
        VectorFloatMicroConstructor.subst(microiop) + \
        VectorFloatMicroExecute.subst(microiop) + \
        VectorFloatMacroDeclare.subst(iop) + \
        VectorFloatMacroConstructor.subst(iop)
    decode_block = VectorFloatDecodeBlock.subst(iop)
}};

def format VectorFloatMaskFormat(code, category, *flags) {{
    iop = InstObjParams(name,
        Name,
        'VectorFloatMaskMacroOp',
        {'code': code},
        flags)
    dest_reg_id = "RegId(VecRegClass, extMachInst.vd)"
    src1_reg_id = ""
    if category == "OPFVV":
        src1_reg_id = "RegId(VecRegClass, extMachInst.vs1 + _micro_idx)"
    elif category == "OPFVF":
        src1_reg_id = "RegId(FloatRegClass, extMachInst.rs1)"
    else:
        error("not supported category for VectorIntFormat: %s" % category)
    src2RegId = "RegId(VecRegClass, extMachInst.vs2 + _micro_idx)"
    set_dest_reg_idx = setDestWrapper(dest_reg_id)
    set_src_reg_idx = ""
    set_src_reg_idx += setSrcWrapper(src1_reg_id)
    set_src_reg_idx += setSrcWrapper(src2RegId)
    set_src_reg_idx += setSrcVm()
    vm_decl_rd = vmDeclAndReadData()

    code = eiDeclarePrefix(code)
    code = loopWrapper(code)

    microiop = InstObjParams(name + "_micro",
        Name + "Micro",
        'VectorFloatMicroOp',
        {'code': code,
        'set_dest_reg_idx': set_dest_reg_idx,
        'set_src_reg_idx': set_src_reg_idx,
        'vm_decl_rd': vm_decl_rd},
        flags)
    header_output = \
        VectorFloatMaskMicroDeclare.subst(microiop) + \
        VectorFloatMaskMicroConstructor.subst(microiop) + \
        VectorFloatMaskMicroExecute.subst(microiop) + \
        VectorFloatMaskMacroDeclare.subst(iop) + \
        VectorFloatMaskMacroConstructor.subst(iop)
    decode_block = VectorFloatDecodeBlock.subst(iop)
}};